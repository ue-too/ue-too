/**
 * RuleEngine - Central manager for all game rules.
 *
 * Manages rule registration, event matching, and rule execution with priority ordering.
 */

import type { Entity } from '@ue-too/ecs';
import type { Rule, Event, GameState, Effect } from '../core/types';
import { RuleContext } from './rule-context';
import { EventPattern } from '../event-system/event-pattern';
import { ActionContext } from '../action-system/action-context';
import { RuleExecutionError } from '../core/types';

/**
 * Rule engine implementation that processes events and executes matching rules.
 *
 * @example
 * ```typescript
 * const ruleEngine = new RuleEngine();
 *
 * // Add global rule
 * ruleEngine.addGlobalRule({
 *   id: 'draw-on-spell',
 *   trigger: new EventPattern('CardPlayed', { cardType: 'Spell' }),
 *   conditions: [],
 *   effects: [new DrawCardEffect()],
 *   priority: 100
 * });
 *
 * // Process event
 * const newEvents = ruleEngine.processEvent(state, event);
 * ```
 */
export class RuleEngine {
  private globalRules: Rule[] = [];
  private entityRules: Map<Entity, Rule[]> = new Map();
  private ruleIndex: Map<string, Rule[]> = new Map();

  /**
   * Add a global rule (always active).
   *
   * @param rule - Rule to add
   */
  addGlobalRule(rule: Rule): void {
    this.globalRules.push(rule);
    this.indexRule(rule);
  }

  /**
   * Remove a global rule by ID.
   *
   * @param ruleId - ID of rule to remove
   * @returns True if rule was found and removed
   */
  removeGlobalRule(ruleId: string): boolean {
    const index = this.globalRules.findIndex((r) => r.id === ruleId);
    if (index !== -1) {
      const rule = this.globalRules[index];
      this.globalRules.splice(index, 1);
      this.unindexRule(rule);
      return true;
    }
    return false;
  }

  /**
   * Add an entity-specific rule (only active while entity exists).
   *
   * @param entityId - Entity to attach rule to
   * @param rule - Rule to add
   */
  addEntityRule(entityId: Entity, rule: Rule): void {
    if (!this.entityRules.has(entityId)) {
      this.entityRules.set(entityId, []);
    }
    this.entityRules.get(entityId)!.push(rule);
    this.indexRule(rule);
  }

  /**
   * Remove an entity-specific rule by ID.
   *
   * @param entityId - Entity the rule is attached to
   * @param ruleId - ID of rule to remove
   * @returns True if rule was found and removed
   */
  removeEntityRule(entityId: Entity, ruleId: string): boolean {
    const rules = this.entityRules.get(entityId);
    if (!rules) return false;

    const index = rules.findIndex((r) => r.id === ruleId);
    if (index !== -1) {
      const rule = rules[index];
      rules.splice(index, 1);
      this.unindexRule(rule);

      // Clean up empty entity rule lists
      if (rules.length === 0) {
        this.entityRules.delete(entityId);
      }

      return true;
    }
    return false;
  }

  /**
   * Index a rule by its trigger event type for faster lookups.
   *
   * @param rule - Rule to index
   */
  private indexRule(rule: Rule): void {
    const eventType = rule.trigger.eventType;
    if (!this.ruleIndex.has(eventType)) {
      this.ruleIndex.set(eventType, []);
    }
    this.ruleIndex.get(eventType)!.push(rule);
  }

  /**
   * Remove a rule from the index.
   *
   * @param rule - Rule to unindex
   */
  private unindexRule(rule: Rule): void {
    const eventType = rule.trigger.eventType;
    const rules = this.ruleIndex.get(eventType);
    if (rules) {
      const index = rules.indexOf(rule);
      if (index !== -1) {
        rules.splice(index, 1);
      }
      if (rules.length === 0) {
        this.ruleIndex.delete(eventType);
      }
    }
  }

  /**
   * Process an event through all matching rules.
   *
   * @param state - Current game state
   * @param event - Event to process
   * @returns Array of new events generated by rule effects
   */
  processEvent(state: GameState, event: Event): Event[] {
    // Find all matching rules
    const triggeredRules = this.findMatchingRules(state, event);

    // Sort by priority (higher priority first)
    triggeredRules.sort((a, b) => b.priority - a.priority);

    // Execute rules and collect generated events
    const generatedEvents: Event[] = [];

    for (const rule of triggeredRules) {
      try {
        const context = new RuleContext(state, event, rule, []);

        // Check all conditions
        const allConditionsPass = rule.conditions.every((condition) =>
          condition.evaluate(state, context)
        );

        if (allConditionsPass) {
          // Apply effects
          for (const effect of rule.effects) {
            // Create a temporary action context for effects
            // (effects are shared between actions and rules)
            const actionContext = this.createActionContextForRule(state, context);

            try {
              effect.apply(actionContext);

              // Collect generated events
              if (effect.generatesEvent()) {
                const newEvent = effect.createEvent(actionContext);
                if (newEvent) {
                  generatedEvents.push(newEvent);
                }
              }
            } catch (error) {
              console.error(`Error applying effect in rule ${rule.id}:`, error);
              throw new RuleExecutionError(
                rule,
                event,
                error instanceof Error ? error : new Error(String(error))
              );
            }
          }
        }
      } catch (error) {
        console.error(`Error processing rule ${rule.id}:`, error);
        // Continue processing other rules
      }
    }

    return generatedEvents;
  }

  /**
   * Find all rules that match an event.
   *
   * @param state - Current game state
   * @param event - Event to match
   * @returns Array of matching rules
   */
  private findMatchingRules(state: GameState, event: Event): Rule[] {
    const matchingRules: Rule[] = [];

    // Check indexed rules for this event type
    const indexedRules = this.ruleIndex.get(event.type) ?? [];
    for (const rule of indexedRules) {
      const pattern = new EventPattern(rule.trigger.eventType, rule.trigger.filters);
      if (pattern.matches(event)) {
        matchingRules.push(rule);
      }
    }

    // Check wildcard rules
    const wildcardRules = this.ruleIndex.get('*') ?? [];
    for (const rule of wildcardRules) {
      const pattern = new EventPattern(rule.trigger.eventType, rule.trigger.filters);
      if (pattern.matches(event)) {
        matchingRules.push(rule);
      }
    }

    return matchingRules;
  }

  /**
   * Create an ActionContext for rule effects to use.
   * Since effects are shared between actions and rules, we need to provide a context.
   *
   * @param state - Game state
   * @param ruleContext - Rule context
   * @returns Action context for effects
   */
  private createActionContextForRule(state: GameState, ruleContext: RuleContext): ActionContext {
    // Create a dummy action for the context
    const action = {
      type: 'RuleEffect',
      actorId: ruleContext.rule.source ?? 0,
      targetIds: [],
      parameters: ruleContext.event.data,
    };

    return new ActionContext(
      state,
      action,
      ruleContext.rule.source ?? 0,
      [],
      ruleContext.event.data
    );
  }

  /**
   * Get all active rules (global + entity rules for existing entities).
   *
   * @param state - Game state to check entity existence
   * @returns Array of all active rules
   */
  getAllActiveRules(state: GameState): Rule[] {
    const activeRules: Rule[] = [...this.globalRules];

    // Add entity rules for entities that exist
    const allEntities = state.coordinator.getAllEntities();
    for (const entity of allEntities) {
      const rules = this.entityRules.get(entity);
      if (rules) {
        activeRules.push(...rules);
      }
    }

    return activeRules;
  }

  /**
   * Clear all rules.
   */
  clearAll(): void {
    this.globalRules = [];
    this.entityRules.clear();
    this.ruleIndex.clear();
  }

  /**
   * Get the number of global rules.
   *
   * @returns Count of global rules
   */
  getGlobalRuleCount(): number {
    return this.globalRules.length;
  }

  /**
   * Get the number of entity rules.
   *
   * @returns Count of entity rules
   */
  getEntityRuleCount(): number {
    let count = 0;
    for (const rules of this.entityRules.values()) {
      count += rules.length;
    }
    return count;
  }
}
